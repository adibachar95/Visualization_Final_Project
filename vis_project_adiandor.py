# -*- coding: utf-8 -*-
"""vis_project_AdiAndOr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CdGRON5weg95XRJOkUuNbURKnWqhm84-

Imports & Drive Mount
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

DATA_PATH = "/content/drive/MyDrive/Colab Notebooks/output.csv"

df_raw = pd.read_csv(DATA_PATH)
print("Raw dataset shape:", df_raw.shape)

df_raw.head()

df_raw.info()
df_raw.describe(include="all").T.head(20)

import pandas as pd
import numpy as np

"""Date/Time Cleaning + Unified Timestamp.
Visualization tasks require a reliable time dimension:

* parse CRASH DATE as datetime
* validate CRASH TIME format (HH:MM)
* build a unified timestamp (crash_datetime)

"""

df = df_raw.copy()

# Parse crash date
df["CRASH DATE"] = pd.to_datetime(df["CRASH DATE"], errors="coerce")

# Clean crash time (keep as string, validate HH:MM)
df["CRASH TIME"] = df["CRASH TIME"].astype(str).str.strip()
valid_time = df["CRASH TIME"].str.match(r"^\d{1,2}:\d{2}$", na=False)

# Filter invalid rows
before = len(df)
df = df.dropna(subset=["CRASH DATE"])
df = df[valid_time].copy()
after = len(df)
print(f"Removed {before-after:,} rows with invalid/missing date or time.")

# Create unified timestamp
df["crash_datetime"] = pd.to_datetime(
    df["CRASH DATE"].dt.strftime("%Y-%m-%d") + " " + df["CRASH TIME"],
    errors="coerce"
)
df = df.dropna(subset=["crash_datetime"]).copy()

print("After crash_datetime creation:", df.shape)
df[["CRASH DATE", "CRASH TIME", "crash_datetime"]].head()

"""Time Feature Engineering (Year/Month/Weekday/Hour)"""

df["year"] = df["crash_datetime"].dt.year
df["month"] = df["crash_datetime"].dt.to_period("M").astype(str)
df["day_of_week"] = df["crash_datetime"].dt.day_name()
df["hour"] = df["crash_datetime"].dt.hour

# Enforce an ordered weekday category for consistent plotting
dow_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
df["day_of_week"] = pd.Categorical(df["day_of_week"], categories=dow_order, ordered=True)

# Define hour buckets for higher-level comparisons
def hour_bucket(h: int) -> str:
    if 0 <= h <= 5:
        return "Night (00-05)"
    elif 6 <= h <= 11:
        return "Morning (06-11)"
    elif 12 <= h <= 17:
        return "Afternoon (12-17)"
    else:
        return "Evening (18-23)"

df["hour_bucket"] = df["hour"].apply(hour_bucket)
df["hour_bucket"] = pd.Categorical(
    df["hour_bucket"],
    categories=["Night (00-05)", "Morning (06-11)", "Afternoon (12-17)", "Evening (18-23)"],
    ordered=True
)

df[["year", "month", "day_of_week", "hour", "hour_bucket"]].head()

"""Numeric Casting for Injury/Killed Measures. We convert injury/killed columns to numeric. This prevents string-based issues and supports correct aggregation.

"""

num_cols = [
    "LATITUDE", "LONGITUDE",
    "NUMBER OF PERSONS INJURED", "NUMBER OF PERSONS KILLED",
    "NUMBER OF PEDESTRIANS INJURED", "NUMBER OF PEDESTRIANS KILLED",
    "NUMBER OF CYCLIST INJURED", "NUMBER OF CYCLIST KILLED",
    "NUMBER OF MOTORIST INJURED", "NUMBER OF MOTORIST KILLED",
]

for c in num_cols:
    if c in df.columns:
        df[c] = pd.to_numeric(df[c], errors="coerce")

df[num_cols].head()

"""Severity Label (Human-readable):  We create a clear severity category for visualization:
*   Fatal: at least one person killed
*   Injury: no fatalities, but at least one injured
*   No injury reported: otherwise
*   This is suitable for color encodings, faceting, and filtering.
"""

inj = df["NUMBER OF PERSONS INJURED"].fillna(0)
kill = df["NUMBER OF PERSONS KILLED"].fillna(0)

df["severity_label"] = np.select(
    [kill > 0, inj > 0],
    ["Fatal", "Injury"],
    default="No injury reported"
)

df["severity_label"].value_counts(dropna=False)

"""Cleaning Core Categorical Fields (Borough, Factor, Vehicle Type): Categorical fields often contain missing values and inconsistent
formatting. Cleaning improves interpretability and prevents fragmentation in "Top-N" plots.
"""

# Borough
df["borough_clean"] = (
    df["BOROUGH"]
    .fillna("Unknown")
    .astype(str)
    .str.strip()
    .str.title()
)
df.loc[df["borough_clean"].isin(["", "Nan", "None"]), "borough_clean"] = "Unknown"

# Primary contributing factor (Vehicle 1)
factor_col = "CONTRIBUTING FACTOR VEHICLE 1"
df["factor_primary"] = (
    df[factor_col]
    .fillna("Unspecified")
    .astype(str)
    .str.strip()
)
df.loc[df["factor_primary"].isin(["", "nan", "None"]), "factor_primary"] = "Unspecified"

# Primary vehicle type (Vehicle 1)
veh_primary_col = "VEHICLE TYPE CODE 1"
df["vehicle_type_primary"] = (
    df[veh_primary_col]
    .fillna("Unknown")
    .astype(str)
    .str.strip()
)
df.loc[df["vehicle_type_primary"].isin(["", "nan", "None"]), "vehicle_type_primary"] = "Unknown"

df[["borough_clean", "factor_primary", "vehicle_type_primary"]].head()

"""Vehicles Table (Long Format) + Number of Vehicles Involved: The crashes dataset stores up to 5 vehicle types per crash as separate columns (VEHICLE TYPE CODE 1..5). For richer analysis we convert these columns into a long table: each row = one vehicle-slot observation per crash.
This supports:
* top vehicle types overall
* severity by vehicle type
* number of involved vehicles per crash
"""

veh_cols = [c for c in df.columns if c.startswith("VEHICLE TYPE CODE")]

base_cols = ["COLLISION_ID", "crash_datetime", "year", "month", "borough_clean", "severity_label"]

veh_long = (
    df[base_cols + veh_cols]
    .melt(
        id_vars=base_cols,
        value_vars=veh_cols,
        var_name="vehicle_slot",
        value_name="vehicle_type"
    )
)

veh_long["vehicle_type"] = veh_long["vehicle_type"].fillna("Unknown").astype(str).str.strip()
veh_long = veh_long[veh_long["vehicle_type"].ne("")].copy()

# Count involved vehicles per collision (excluding Unknown)
num_vehicles = (
    veh_long[veh_long["vehicle_type"].ne("Unknown")]
    .groupby("COLLISION_ID")
    .size()
    .rename("num_vehicles_involved")
    .reset_index()
)

df = df.merge(num_vehicles, on="COLLISION_ID", how="left")
df["num_vehicles_involved"] = df["num_vehicles_involved"].fillna(0).astype(int)

print("veh_long shape:", veh_long.shape)
df[["COLLISION_ID", "num_vehicles_involved"]].head()

"""People Table (Derived from Injured/Killed by Road User Type): #
While we do not use the separate NYC Persons dataset here, the
crashes table already provides injury/killed counts by road-user type.
We convert these measures into a long table:
each row = (collision_id, role, outcome, count).
This supports visualizations such as:
* injured vs killed over time by role
* role distribution across boroughs
* temporal risk patterns for pedestrians/cyclists
"""

people_measures = [
    ("NUMBER OF PEDESTRIANS INJURED", "Pedestrian", "Injured"),
    ("NUMBER OF PEDESTRIANS KILLED",  "Pedestrian", "Killed"),
    ("NUMBER OF CYCLIST INJURED",     "Cyclist",    "Injured"),
    ("NUMBER OF CYCLIST KILLED",      "Cyclist",    "Killed"),
    ("NUMBER OF MOTORIST INJURED",    "Motorist",   "Injured"),
    ("NUMBER OF MOTORIST KILLED",     "Motorist",   "Killed"),
]

tmp = df[base_cols + ["day_of_week", "hour", "hour_bucket"]].copy()

parts = []
for col, role, outcome in people_measures:
    s = df[col].fillna(0)
    part = tmp.copy()
    part["role"] = role
    part["outcome"] = outcome
    part["count"] = s.astype(int)
    parts.append(part)

people_long = pd.concat(parts, ignore_index=True)

print("people_long shape:", people_long.shape)
people_long.head()

"""Geo Subset for Maps: For map-based visualizations we require valid latitude/longitude."""

df_geo = df.dropna(subset=["LATITUDE", "LONGITUDE"]).copy()

print("df_geo shape:", df_geo.shape)
df_geo[["LATITUDE", "LONGITUDE"]].head()

"""Helper Aggregation Tables for Visualization"""

# Monthly crash counts by borough (trend lines)
monthly_counts = (
    df.groupby(["month", "borough_clean"], as_index=False)
      .size()
      .rename(columns={"size": "crashes"})
)

# Heatmap table: crashes by weekday and hour
heatmap_day_hour = (
    df.groupby(["day_of_week", "hour"], as_index=False)
      .size()
      .rename(columns={"size": "crashes"})
)

# Top contributing factors (primary)
top_factors = (
    df.groupby("factor_primary", as_index=False)
      .size()
      .rename(columns={"size": "crashes"})
      .sort_values("crashes", ascending=False)
      .head(20)
)

# Severity by vehicle type (from long vehicle table)
severity_by_vehicle = (
    veh_long.groupby(["vehicle_type", "severity_label"], as_index=False)
            .size()
            .rename(columns={"size": "crashes"})
)

monthly_counts.head(), heatmap_day_hour.head(), top_factors.head(), severity_by_vehicle.head()

"""Export Clean Tables (for GitHub):
* crashes_clean.csv (main table)
* crashes_geo.csv (map-ready subset)
* vehicles_long.csv (derived vehicles table)
* people_long.csv (derived people table)
* helper aggregations (monthly_counts, heatmap_day_hour, etc.)
"""

import os

OUT_DIR = "/content/drive/MyDrive/Colab Notebooks/vis_project_outputs"
os.makedirs(OUT_DIR, exist_ok=True)

df.to_csv(f"{OUT_DIR}/crashes_clean.csv", index=False)
df_geo.to_csv(f"{OUT_DIR}/crashes_geo.csv", index=False)
veh_long.to_csv(f"{OUT_DIR}/vehicles_long.csv", index=False)
people_long.to_csv(f"{OUT_DIR}/people_long.csv", index=False)

monthly_counts.to_csv(f"{OUT_DIR}/monthly_counts.csv", index=False)
heatmap_day_hour.to_csv(f"{OUT_DIR}/heatmap_day_hour.csv", index=False)
top_factors.to_csv(f"{OUT_DIR}/top_factors.csv", index=False)
severity_by_vehicle.to_csv(f"{OUT_DIR}/severity_by_vehicle.csv", index=False)

print("Exported all outputs to:", OUT_DIR)

"""Sanity checks:"""

print("Final main table shape:", df.shape)
print("Date range:", df["crash_datetime"].min(), "->", df["crash_datetime"].max())
print("Severity distribution:\n", df["severity_label"].value_counts())

core_dims = ["crash_datetime", "borough_clean", "severity_label", "factor_primary", "vehicle_type_primary"]
print("\nMissing values in core dimensions:")
print(df[core_dims].isna().sum())

"""# Visualization 1 - Data aggregation (monthly trend by borough)

"""

import pandas as pd

if "monthly_counts" not in globals():
    monthly_counts = (
        df.groupby(["month", "borough_clean"], as_index=False)
          .size()
          .rename(columns={"size": "crashes"})
    )

# Convert 'month' to a proper datetime for correct sorting/plotting
monthly_counts["month_dt"] = pd.to_datetime(monthly_counts["month"] + "-01")

monthly_counts_plot = monthly_counts[monthly_counts["borough_clean"] != "Unknown"].copy()

print(monthly_counts_plot.shape)
monthly_counts_plot.head()

"""Static line chart (Matplotlib)

Interactive line chart (Plotly)
"""

import plotly.express as px
import pandas as pd

# Make sure month_dt exists
monthly_counts_plot["month_dt"] = pd.to_datetime(monthly_counts_plot["month_dt"])

# Create a clean "Month Year" string for hover
monthly_counts_plot["month_year"] = monthly_counts_plot["month_dt"].dt.strftime("%b %Y")  # e.g., "Jan 2015"

fig = px.line(
    monthly_counts_plot,
    x="month_dt",
    y="crashes",
    color="borough_clean",
    title="A Rare Bright Spot of COVID-19: Fewer Traffic Crashes on NYC Streets in 2020",
    labels={
        "month_dt": "Month",
        "crashes": "Number of crashes",
        "borough_clean": "Borough"
    },

    hover_data={
        "month_year": True,
        "month_dt": False
    }
)

fig.update_layout(
    hovermode="x unified",
    legend_title_text="Borough",
)

# Force full timeline + yearly ticks
fig.update_xaxes(
    range=["2012-01-01", "2026-12-31"],
    dtick="M12",
    tickformat="%Y"
)

fig.update_traces(
    hovertemplate=
    "<b>%{customdata[0]}</b><br>" +
    "Borough: %{legendgroup}<br>" +
    "Crashes: %{y}<extra></extra>"
)

fig.show()

!pip -q install plotly

import os
from IPython.display import HTML, display

OUT_DIR = "/content"
HTML_NAME = "viz1_covid_crash_drop_2020.html"
html_path = os.path.join(OUT_DIR, HTML_NAME)

fig.write_html(html_path, include_plotlyjs="cdn", full_html=True)

display(HTML(f"""
<a href="/files/{HTML_NAME}" download style="
    display:inline-block;
    padding:10px 14px;
    background:#2d6cdf;
    color:white;
    border-radius:8px;
    text-decoration:none;
    font-weight:600;
">
Download interactive HTML: {HTML_NAME}
</a>
"""))

"""# Visualization 2 - heatmap data by severity

"""

import pandas as pd

# Aggregate crashes by severity, weekday, and hour
heatmap_severity = (
    df.groupby(["severity_label", "day_of_week", "hour"], as_index=False)
      .size()
      .rename(columns={"size": "crashes"})
)

# Ensure consistent hour ordering
heatmap_severity["hour"] = heatmap_severity["hour"].astype(int)

heatmap_severity.head()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# Ensure numeric columns are usable
df["NUMBER OF PERSONS INJURED"] = pd.to_numeric(df["NUMBER OF PERSONS INJURED"], errors="coerce").fillna(0)
df["NUMBER OF PERSONS KILLED"]  = pd.to_numeric(df["NUMBER OF PERSONS KILLED"],  errors="coerce").fillna(0)

# Make sure day_of_week is ordered correctly
dow_order = ["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"]
df["day_of_week"] = pd.Categorical(df["day_of_week"], categories=dow_order, ordered=True)

hours = list(range(24))

# Count of "No injury reported" crashes
noinj = df[df["severity_label"] == "No injury reported"]
noinj_table = (
    noinj.groupby(["day_of_week","hour"])
         .size()
         .reset_index(name="value")
)
noinj_matrix = (
    noinj_table.pivot(index="day_of_week", columns="hour", values="value")
               .reindex(index=dow_order, columns=hours)
               .fillna(0)
)

# Sum of injuries across ALL crashes
inj_table = (
    df.groupby(["day_of_week","hour"], as_index=False)["NUMBER OF PERSONS INJURED"]
      .sum()
      .rename(columns={"NUMBER OF PERSONS INJURED":"value"})
)
inj_matrix = (
    inj_table.pivot(index="day_of_week", columns="hour", values="value")
             .reindex(index=dow_order, columns=hours)
             .fillna(0)
)

# Sum of deaths across ALL crashes
kill_table = (
    df.groupby(["day_of_week","hour"], as_index=False)["NUMBER OF PERSONS KILLED"]
      .sum()
      .rename(columns={"NUMBER OF PERSONS KILLED":"value"})
)
kill_matrix = (
    kill_table.pivot(index="day_of_week", columns="hour", values="value")
              .reindex(index=dow_order, columns=hours)
              .fillna(0)
)

# Plot: three stacked heatmaps

fig, axes = plt.subplots(nrows=3, ncols=1, figsize=(14, 12), sharex=True)

panels = [
    (noinj_matrix, "Crashes by Day and Hour - Metric: Count of 'No injury reported' crashes"),
    (inj_matrix,   "Crashes by Day and Hour - Metric: Sum of injuries"),
    (kill_matrix,  "Crashes by Day and Hour - Metric: Sum of deaths")
]

for ax, (mat, title) in zip(axes, panels):
    im = ax.imshow(mat.values, aspect="auto", cmap="YlOrRd")  # higher = darker
    ax.set_title(title)
    ax.set_ylabel("Day of week")
    ax.set_yticks(range(len(mat.index)))
    ax.set_yticklabels(mat.index)

    cbar = fig.colorbar(im, ax=ax)
    cbar.set_label("Value")

axes[-1].set_xlabel("Hour of day")
axes[-1].set_xticks(range(24))
axes[-1].set_xticklabels(range(24))

plt.tight_layout()
plt.show()

print("Max 'No injury' count in any cell:", int(noinj_matrix.values.max()))
print("Max injuries sum in any cell:", float(inj_matrix.values.max()))
print("Max deaths sum in any cell:", float(kill_matrix.values.max()))

# How many FATAL crashes in the dataset
fatal_count = (df["severity_label"] == "Fatal").sum()
total_count = len(df)

print("Total rows:", total_count)
print("Fatal crashes:", fatal_count)
print("Fatal percentage:", round(fatal_count / total_count * 100, 4), "%")

fatal_heat = (
    df[df["severity_label"] == "Fatal"]
    .groupby(["day_of_week", "hour"])
    .size()
    .reset_index(name="fatal_crashes")
)

print("Max fatal crashes in any (day, hour) cell:", fatal_heat["fatal_crashes"].max())

fatal_heat.sort_values("fatal_crashes", ascending=False).head(10)

"""Visualization 3 — Where crashes happen: Interactive Density Map (NYC)"""

import pandas as pd
import numpy as np

# Ensure geo data exists
if "df_geo" not in globals():
    df_geo = df.dropna(subset=["LATITUDE", "LONGITUDE"]).copy()

df_geo["LATITUDE"] = pd.to_numeric(df_geo["LATITUDE"], errors="coerce")
df_geo["LONGITUDE"] = pd.to_numeric(df_geo["LONGITUDE"], errors="coerce")
df_geo = df_geo.dropna(subset=["LATITUDE", "LONGITUDE"]).copy()

# Remove extreme coordinate outliers (keeps NYC area)
df_geo = df_geo[
    (df_geo["LATITUDE"].between(40.40, 40.95)) &
    (df_geo["LONGITUDE"].between(-74.30, -73.60))
].copy()

# Filter to fatal crashes only
df_fatal = df_geo[df_geo["severity_label"] == "Fatal"].copy()
print("Fatal geo rows:", df_fatal.shape)

N = 30000
if len(df_fatal) > N:
    df_fatal_plot = df_fatal.sample(N, random_state=42).copy()
else:
    df_fatal_plot = df_fatal.copy()

df_fatal_plot.head()

"""# Visualization 3 - Interactive Map: Severe Accidents"""

import folium
from folium.plugins import MarkerCluster
import pandas as pd


# Filter only severe accidents (Injuries or Fatalities) with valid location data.
filtered_df = df[
    ((df['NUMBER OF PERSONS INJURED'] > 0) | (df['NUMBER OF PERSONS KILLED'] > 0)) &
    (df['LATITUDE'].notna()) &
    (df['LONGITUDE'].notna())
].copy()

print(f"Showing {len(filtered_df)} severe accidents on the map...")


# Center the map based on the average coordinates of the filtered data.
m = folium.Map(location=[filtered_df['LATITUDE'].mean(), filtered_df['LONGITUDE'].mean()],
               zoom_start=11,
               tiles='CartoDB positron')

marker_cluster = MarkerCluster().add_to(m)


for index, row in filtered_df.iterrows():

    # Convert to datetime object and format as DD/MM/YYYY
    try:
        clean_date = pd.to_datetime(row['CRASH DATE']).strftime('%d/%m/%Y')
    except:
        clean_date = str(row['CRASH DATE']) # Fallback if error

    # Calculate stats
    killed = row['NUMBER OF PERSONS KILLED']
    injured = row['NUMBER OF PERSONS INJURED']

    # Determine Color (Red for Fatal, Orange for Injury)
    if killed > 0:
        icon_color = 'red'
        icon_type = 'exclamation-sign'
    else:
        icon_color = 'orange'
        icon_type = 'info-sign'

    # Create HTML Popup content
    popup_text = f"""
    <div style="font-family: sans-serif; width: 200px;">
        <h4 style="margin-bottom:5px;">Accident Details</h4>
        <b>Date:</b> {clean_date}<br>
        <b>Time:</b> {row['CRASH TIME']}<br>
        <b>Cause:</b> {row['CONTRIBUTING FACTOR VEHICLE 1']}<br>
        <hr style="margin: 5px 0;">
        <b style="color:red;">Killed: {int(killed)}</b><br>
        <b style="color:orange;">Injured: {int(injured)}</b>
    </div>
    """

    # Add Marker to Cluster
    folium.Marker(
        location=[row['LATITUDE'], row['LONGITUDE']],
        popup=folium.Popup(popup_text, max_width=300),
        tooltip="Click for details",
        icon=folium.Icon(color=icon_color, icon=icon_type)
    ).add_to(marker_cluster)

output_file = 'nyc_severe_accidents.html'
m.save(output_file)
print(f"Map saved as '{output_file}'. Download it to view interactively.")
m

"""# Visualiation 4 - Treet map: VEHICLE TYPE"""

import plotly.express as px


# Custom Aggregation - map_vehicle_type
def map_vehicle_type(v):
    v = str(v).upper()

    # handle missing-ish
    if v in ["", "NAN", "NONE", "UNKNOWN", "NAN"]:
        return "UNKNOWN"

    # SPORTS vehicle
    if any(x in v for x in ["SPORT", "CONVERTIBLE"]):
        return "SPORTS_VEHICLE"

    # Taxi / Livery
    if any(x in v for x in ["TAXI", "LIVERY"]):
        return "TAXI_LIVERY"

    # Emergency
    if any(x in v for x in ["EMERGENCY", "POLICE", "AMBULANCE", "FIRE", "AMBUL"]):
        return "EMERGENCY_VEHICLE"

    # Two wheel motor
    if any(x in v for x in ["MOTORCYCLE", "SCOOTER", "MOPED"]):
        return "TWO_WHEEL_MOTOR"

    # Bicycle
    if any(x in v for x in ["BICYCLE", "BIKE"]):
        return "BICYCLE"

    # Pedestrian
    if "PEDESTRIAN" in v:
        return "PEDESTRIAN"

    # Heavy / Commercial
    if any(x in v for x in [
        "TRUCK", "BUS", "DELIVERY", "TRACTOR", "SEMI",
        "LARGE COM VEH", "SMALL COM VEH", "COM VEH",
        "DUMP", "FLAT BED", "GARBAGE", "REFUSE", "TANKER",
        "CONCRETE", "CHASSIS", "PK"
    ]):
        return "HEAVY_VEHICLE"

    # Private vehicles
    if any(x in v for x in [
        "CAR", "SEDAN", "SUV", "VAN",
        "PASSENGER", "STATION WAGON", "SPORT UTILITY",
        "SPORT UTILITY / STATION WAGON", "3-DOOR", "SUBN"
    ]):
        return "PRIVATE_VEHICLE"

    return "OTHER"

df['Vehicle_Category'] = df['VEHICLE TYPE CODE 1'].apply(map_vehicle_type)

print("Vehicle categories created successfully based on your function.")

import plotly.express as px


def map_contributing_factor(v):
    v = str(v)

    # Missing / unknown
    if v in ["UNKNOWN"]:
        return "UNKNOWN"
    if v in ["", "NAN", "NONE", "UNSPECIFIED"]:
        return "UNSPECIFIED"

    # Phone & distraction
    if any(x in v for x in ["CELL", "PHONE", "TEXT", "DISTRACTION", "INATTENTION"]):
        return "DISTRACTION_PHONE"

    # Alcohol / drugs
    if any(x in v for x in ["ALCOHOL", "DRUG", "IMPAIR", "INTOXIC"]):
        return "IMPAIRMENT"

    # Speed
    if "SPEED" in v:
        return "SPEEDING"

    # Traffic control
    if any(x in v for x in ["TRAFFIC CONTROL", "SIGN", "SIGNAL", "LIGHT"]):
        return "TRAFFIC_CONTROL"

    # Vehicle failure
    if any(x in v for x in ["BRAKE", "TIRE", "TYRE", "STEERING", "MECHANICAL", "ACCELERATOR", "ENGINE", "DEFECT", "FAILURE"]):
        return "VEHICLE_FAILURE"

    # Road / environment
    if any(x in v for x in ["ROAD", "WEATHER", "WET", "ICE", "SNOW", "FOG", "POTHOLE", "PAVEMENT", "SLIPPERY", "DEBRIS", "OBSTRUCTION"]):
        return "ROAD_ENVIRONMENT"

    # Visibility
    if any(x in v for x in ["VIEW OBSTRUCTED", "OBSTRUCTED", "LIMITED", "GLARE"]):
        return "VISIBILITY"

    # Medical
    if any(x in v for x in ["LOST CONSCIOUSNESS", "ILLNESS", "PRESCRIPTION", "MEDICATION", "PHYSICAL DISABILITY"]):
        return "MEDICAL_CONDITION"

    # Pedestrian / Cyclist behavior
    if any(x in v for x in ["PEDESTRIAN", "BICYCLIST", "CYCLIST"]):
        return "PEDESTRIAN_CYCLIST"

    # Fatigue
    if any(x in v for x in ["FATIGUE", "ASLEEP", "DROWSY"]):
        return "FATIGUE_SLEEP"

    # Aggressive driving
    if any(x in v for x in ["AGGRESSIVE", "ROAD RAGE"]):
        return "AGGRESSIVE_DRIVING"

    # Driving maneuvers (bad driving)
    if any(x in v for x in ["FAILURE TO YIELD", "RIGHT-OF-WAY", "FOLLOWING TOO CLOSELY", "UNSAFE LANE", "LANE", "PASSING", "TURNING IMPROPERLY", "BACKING UNSAFELY", "DRIVER INEXPERIENCE", "FAILURE TO KEEP RIGHT", "REACTION TO UNINVOLVED VEHICLE"]):
        return "DRIVING_MANEUVER"

    # Other vehicular
    if any(x in v for x in ["OTHER VEHICULAR", "DRIVERLESS", "RUNAWAY VEHICLE"]):
        return "OTHER_VEHICULAR"

    # Vehicle characteristics
    if "OVERSIZED" in v:
        return "VEHICLE_CHARACTERISTICS"

    # External hazards
    if "ANIMALS" in v:
        return "ANIMALS"

    return "OTHER"

def map_vehicle_type(v):
    v = str(v).upper()
    if v in ["", "NAN", "NONE", "UNKNOWN"]: return "UNKNOWN"
    if any(x in v for x in ["SPORT", "CONVERTIBLE"]): return "SPORTS_VEHICLE"
    if any(x in v for x in ["TAXI", "LIVERY"]): return "TAXI_LIVERY"
    if any(x in v for x in ["EMERGENCY", "POLICE", "AMBULANCE", "FIRE"]): return "EMERGENCY_VEHICLE"
    if any(x in v for x in ["MOTORCYCLE", "SCOOTER", "MOPED"]): return "TWO_WHEEL_MOTOR"
    if any(x in v for x in ["BICYCLE", "BIKE"]): return "BICYCLE"
    if "PEDESTRIAN" in v: return "PEDESTRIAN"
    if any(x in v for x in ["TRUCK", "BUS", "DELIVERY", "TRACTOR", "SEMI", "COM VEH", "DUMP"]): return "HEAVY_VEHICLE"
    if any(x in v for x in ["CAR", "SEDAN", "SUV", "VAN", "PASSENGER", "WAGON"]): return "PRIVATE_VEHICLE"
    return "OTHER"

df["factor_raw"] = df["CONTRIBUTING FACTOR VEHICLE 1"].astype(str).str.upper().str.strip()

df["factor_coarse"] = df["factor_raw"].apply(map_contributing_factor)

df['Vehicle_Category'] = df['VEHICLE TYPE CODE 1'].apply(map_vehicle_type)

print("Aggregations applied successfully!")

vehicle_stats = df.groupby('Vehicle_Category').agg(
    Count=('CRASH DATE', 'count'),
    Injured=('NUMBER OF PERSONS INJURED', 'sum')
).reset_index()

fig3 = px.treemap(vehicle_stats, path=['Vehicle_Category'], values='Count', color='Injured',
                  title='The "What": Accidents by Vehicle Category', color_continuous_scale='Reds', template='plotly_white')
fig3.show()

"""# Visualization 5 - Bar Chart: CONTRIBUTING FACTOR"""

import pandas as pd
import numpy as np

# Standardize the main contributing factor column (Vehicle 1)
df["CONTRIBUTING_FACTOR_V1"] = (
    df["CONTRIBUTING FACTOR VEHICLE 1"]
    .astype(str)
    .str.upper()
    .str.strip()
)

# Apply your aggregation mapping function
df["factor_group"] = df["CONTRIBUTING_FACTOR_V1"].apply(map_contributing_factor)

# Quick check
df["factor_group"].value_counts().head(15)

import pandas as pd
import numpy as np

# Make sure killed column is numeric
df["NUMBER OF PERSONS KILLED"] = pd.to_numeric(df["NUMBER OF PERSONS KILLED"], errors="coerce").fillna(0)

# Filter out unknown factor groups
df_deaths = df[~df["factor_group"].isin(["UNSPECIFIED", "UNKNOWN"])].copy()

# Keep only rows where at least 1 person was killed
df_deaths = df_deaths[df_deaths["NUMBER OF PERSONS KILLED"] > 0].copy()

# Aggregate: sum of killed people per factor group
deaths_by_factor = (
    df_deaths.groupby("factor_group")["NUMBER OF PERSONS KILLED"]
    .sum()
    .reset_index(name="total_killed")
    .sort_values("total_killed", ascending=False)
)

TOP_N = 10
deaths_by_factor_top = deaths_by_factor.head(TOP_N).copy()

deaths_by_factor_top

import plotly.express as px

fig = px.bar(
    deaths_by_factor_top,
    x="factor_group",
    y="total_killed",
    title="If You Don’t Want to Kill, Don’t Text and Drive",
    labels={
        "factor_group": "Contributing Factor Group",
        "total_killed": "Total people killed"
    }
)

fig.update_layout(
    xaxis_tickangle=-25,
    hovermode="x",
)

fig.update_traces(marker_color="#C97C8B")
fig.show()

"""# Visualizrtion 6 - Normalize Bar Chart: vehicle type and severity"""

import pandas as pd
import numpy as np
import plotly.express as px

# Custom Aggregation - map_vehicle_type
def map_vehicle_type(v):
    v = str(v).upper()

    # handle missing-ish
    if v in ["", "NAN", "NONE", "UNKNOWN", "NAN"]:
        return "UNKNOWN"

    #  SPORTS vehicle
    if any(x in v for x in ["SPORT", "CONVERTIBLE"]):
        return "SPORTS_VEHICLE"

    #  Taxi / Livery
    if any(x in v for x in ["TAXI", "LIVERY"]):
        return "TAXI_LIVERY"

    #  Emergency
    if any(x in v for x in ["EMERGENCY", "POLICE", "AMBULANCE", "FIRE", "AMBUL"]):
        return "EMERGENCY_VEHICLE"

    #  Two wheel motor
    if any(x in v for x in ["MOTORCYCLE", "SCOOTER", "MOPED"]):
        return "TWO_WHEEL_MOTOR"

    #  Bicycle
    if any(x in v for x in ["BICYCLE", "BIKE"]):
        return "BICYCLE"

    #  Pedestrian
    if "PEDESTRIAN" in v:
        return "PEDESTRIAN"

    #  Heavy / Commercial
    if any(x in v for x in [
        "TRUCK", "BUS", "DELIVERY", "TRACTOR", "SEMI",
        "LARGE COM VEH", "SMALL COM VEH", "COM VEH",
        "DUMP", "FLAT BED", "GARBAGE", "REFUSE", "TANKER",
        "CONCRETE", "CHASSIS", "PK"
    ]):
        return "HEAVY_VEHICLE"

    #  Private vehicles
    if any(x in v for x in [
        "CAR", "SEDAN", "SUV", "VAN",
        "PASSENGER", "STATION WAGON", "SPORT UTILITY",
        "SPORT UTILITY / STATION WAGON", "3-DOOR", "SUBN"
    ]):
        return "PRIVATE_VEHICLE"

    return "OTHER"

df["Vehicle_Category"] = df["VEHICLE TYPE CODE 1"].apply(map_vehicle_type)

print("Vehicle categories created successfully based on your function.")
df["Vehicle_Category"].value_counts().head(10)

severity_order = ["No injury reported", "Injury", "Fatal"]

color_map_pastel = {
    "Fatal": "#C97C8B",
    "Injury": "#F4A261",
    "No injury reported": "#F6E58D"
}

import pandas as pd
import numpy as np

severity_candidates = ["severity_label", "SEVERITY_LABEL", "Accident_Severity"]
severity_col = next((c for c in severity_candidates if c in df.columns), None)

if severity_col is None:
    raise ValueError(f"No severity column found. Available columns: {list(df.columns)[:30]} ...")

print("Using severity column:", severity_col)

if "Vehicle_Category" not in df.columns:
    df["Vehicle_Category"] = df["VEHICLE TYPE CODE 1"].apply(map_vehicle_type)
    print("Vehicle_Category created (it was missing).")

df_veh = df[df["Vehicle_Category"] != "UNKNOWN"].copy()

veh_sev_counts = (
    df_veh.groupby(["Vehicle_Category", severity_col])
          .size()
          .reset_index(name="crash_count")
)

veh_sev_counts["total_in_category"] = veh_sev_counts.groupby("Vehicle_Category")["crash_count"].transform("sum")
veh_sev_counts["percent"] = (veh_sev_counts["crash_count"] / veh_sev_counts["total_in_category"]) * 100

veh_order = (
    veh_sev_counts.groupby("Vehicle_Category")["crash_count"]
    .sum()
    .sort_values(ascending=False)
    .index
    .tolist()
)

veh_sev_counts["Vehicle_Category"] = pd.Categorical(
    veh_sev_counts["Vehicle_Category"],
    categories=veh_order,
    ordered=True
)

veh_sev_counts.head()

import pandas as pd
import plotly.express as px

severity_col = "severity_label" if "severity_label" in df.columns else "SEVERITY_LABEL"

df_viz = df.copy()
df_viz["severity_merged"] = df_viz[severity_col].replace({
    "Fatal": "Casualty (Injury or Fatal)",
    "Injury": "Casualty (Injury or Fatal)",
    "No injury reported": "No injury reported"
})

df_viz = df_viz[df_viz["Vehicle_Category"] != "UNKNOWN"].copy()

# Count
veh_counts = (
    df_viz.groupby(["Vehicle_Category", "severity_merged"])
          .size()
          .reset_index(name="crash_count")
)

# Normalize to percent within each vehicle category
veh_counts["total"] = veh_counts.groupby("Vehicle_Category")["crash_count"].transform("sum")
veh_counts["percent"] = veh_counts["crash_count"] / veh_counts["total"] * 100

# Order vehicle categories by volume
veh_order = (
    veh_counts.groupby("Vehicle_Category")["crash_count"].sum()
    .sort_values(ascending=False).index.tolist()
)
veh_counts["Vehicle_Category"] = pd.Categorical(veh_counts["Vehicle_Category"], categories=veh_order, ordered=True)

# Pastel colors (yellow vs orange-red)
color_map = {
    "No injury reported": "#F6E58D",              # pastel yellow
    "Casualty (Injury or Fatal)": "#F4A261"       # pastel orange
}

fig = px.bar(
    veh_counts,
    x="Vehicle_Category",
    y="percent",
    color="severity_merged",
    barmode="stack",
    color_discrete_map=color_map,
    category_orders={"severity_merged": ["No injury reported", "Casualty (Injury or Fatal)"]},
    title="“Small Vehicle, Big Consequences: Two-Wheel Crashes Turn Dangerous Fast",
    labels={
        "Vehicle_Category": "Vehicle category (grouped)",
        "percent": "Share of crashes (%)",
        "severity_merged": "Outcome"
    },
    hover_data={"crash_count": True, "percent": ":.1f"}
)

fig.update_layout(hovermode="x unified", yaxis=dict(range=[0, 100]), xaxis_tickangle=-20)
fig.show()

